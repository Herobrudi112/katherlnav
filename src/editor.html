<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Navigation Graph Editor</title>
  <style>
    :root{--bg:#0f1724;--panel:#0b1220;--muted:#94a3b8;--accent:#06b6d4;--success:#34d399}
    html,body{height:100%;margin:0;font-family:Inter, Roboto, system-ui, -apple-system, sans-serif;background:linear-gradient(180deg,#071028 0%,#081122 100%);color:#e6eef6}
    .app{display:flex;gap:12px;height:100%;padding:12px;box-sizing:border-box}
    .canvas-wrap{flex:1;background:linear-gradient(180deg,#071a2b, #04202a);border-radius:12px;padding:12px;display:flex;flex-direction:column;position:relative}
    canvas{background:transparent;border-radius:8px;flex:1;cursor:crosshair}
    .panel{width:400px;background:var(--panel);border-radius:12px;padding:12px;box-shadow:0 6px 30px rgba(2,6,23,0.6)}
    h1{margin:4px 0 10px;font-size:18px}
    .controls{display:grid;gap:8px}
    label{font-size:12px;color:var(--muted)}
    input,select,button,textarea{width:100%;padding:8px;border-radius:8px;border:1px solid rgba(255,255,255,0.06);background:rgba(255,255,255,0.03);color:#e6eef6}
    select option{background:#0f1724;color:#94a3b8;padding:8px}
    select option:hover{background:#94a3b8}
    button{cursor:pointer;background:linear-gradient(90deg,#0f1724, #0f1724);border:1px solid rgba(6,182,212,0.14)}
    .row{display:flex;gap:8px}
    .row > *{flex:1}
    .small{font-size:12px;padding:6px}
    .list{max-height:160px;overflow:auto;background:rgba(255,255,255,0.02);padding:8px;border-radius:8px}
    .hint{font-size:12px;color:var(--muted)}
    .toolbar{display:flex;gap:8px;margin-bottom:8px;flex-wrap:wrap}
    .node-badge{display:inline-block;padding:6px 8px;border-radius:999px;background:rgba(255,255,255,0.03);font-size:12px}
    .weight-controls{background:rgba(255,255,255,0.02);padding:8px;border-radius:8px;margin-top:8px}
    .weight-row{display:flex;gap:8px;align-items:center;margin-bottom:4px}
    .weight-row input{flex:1}
    .weight-row button{flex-shrink:0;padding:4px 8px;font-size:11px}
    .frame-item:hover{background:rgba(255,255,255,0.05) !important}
    
                   /* Search Bar Styles */
               .search-container {
                   position: absolute;
                   top: 20px;
                   right: 20px;
                   z-index: 1000;
                   width: 250px;
                   pointer-events: none;
               }
               
               .search-container * {
                   pointer-events: auto;
               }
    
    .search-input {
        width: 100%;
        padding: 8px 12px;
        border: 1px solid rgba(255,255,255,0.2);
        border-radius: 6px;
        background: rgba(0,0,0,0.8);
        color: #e6eef6;
        font-size: 14px;
        outline: none;
        transition: border-color 0.2s;
    }
    
    .search-input:focus {
        border-color: #4a9eff;
    }
    
    .search-results {
        position: absolute;
        top: 100%;
        left: 0;
        right: 0;
        background: rgba(0,0,0,0.95);
        border: 1px solid rgba(255,255,255,0.2);
        border-radius: 6px;
        margin-top: 4px;
        max-height: 200px;
        overflow-y: auto;
        display: none;
    }
    
    .search-result-item {
        padding: 8px 12px;
        cursor: pointer;
        border-bottom: 1px solid rgba(255,255,255,0.1);
        transition: background 0.2s;
    }
    
    .search-result-item:hover {
        background: rgba(255,255,255,0.1);
    }
    
    .search-result-item:last-child {
        border-bottom: none;
    }
    
    .search-result-name {
        font-weight: bold;
        color: #e6eef6;
    }
    
    .search-result-building {
        font-size: 12px;
        color: #a0aec0;
        margin-top: 2px;
    }
    
  </style>
</head>
<body>
  <div class="app">
    <div class="canvas-wrap">
      <div class="toolbar">
        <div class="node-badge">Click canvas to add a room</div>
        <div class="node-badge">Drag nodes to reposition</div>
        <div class="node-badge">Shift+Click two nodes to select them, then Connect</div>
        <div class="node-badge">Right-click edges to edit weights</div>
      </div>
      <canvas id="graphCanvas"></canvas>
      
      <!-- Node Search Bar -->
      <div class="search-container">
          <input type="text" id="nodeSearch" placeholder="Search nodes..." class="search-input">
          <div id="searchResults" class="search-results"></div>
      </div>
      
      <div class="hint">Left-click canvas: add node • Click node: select • Drag node: move • Shift+click: multi-select • Right-click edge: edit weight</div>
    </div>

    <div class="panel">
      <h1>Navigation Graph Editor</h1>
      <div class="controls">
        <div>
          <label>Start room name</label>
          <input id="startName" placeholder="e.g. Room A" />
        </div>
        <div>
          <label>End room name</label>
          <input id="endName" placeholder="e.g. Room B" />
        </div>
        <div class="row">
          <button id="findPathBtn">Find shortest path</button>
          <button id="clearHighlightBtn">Clear highlight</button>
        </div>

        <hr style="opacity:.06;border:none;height:1px;background:rgba(255,255,255,0.03)">

        <div>
          <label>Selected nodes (click nodes in canvas)</label>
          <div id="selectedList" class="list">(none)</div>
        </div>
        <div class="row">
          <button id="connectSelectedBtn">Connect selected</button>
          <button id="removeSelectedBtn">Remove selected</button>
        </div>

        <div>
          <label>Connect manually (from → to)</label>
          <div class="row">
            <select id="fromSelect"></select>
            <select id="toSelect"></select>
          </div>
          <label style="margin-top:6px">Weight (leave empty to auto distance)</label>
          <input id="edgeWeight" placeholder="auto" />
          <div class="row" style="margin-top:6px">
            <button id="connectBtn">Connect</button>
            <button id="removeEdgeBtn">Remove edge</button>
          </div>
        </div>

        <div class="weight-controls">
          <label>Edge Weight Editor</label>
          <div id="weightControls">
            <div class="hint">Right-click on an edge to edit its weight</div>
          </div>
        </div>

        <hr style="opacity:.06;border:none;height:1px;background:rgba(255,255,255,0.03)">

        <div>
          <label>Frame Management</label>
          <div class="row">
            <button id="createFrameBtn">Create Frame</button>
            <button id="deleteFrameBtn">Delete Frame</button>
          </div>
          <div>
            <label>Frame name</label>
            <input id="frameNameInput" placeholder="e.g. Building A, Floor 1" />
          </div>
          <div>
            <label>Frame color</label>
            <input type="color" id="frameColorInput" value="#3b82f6" />
          </div>
          <div>
            <label>Frame size</label>
            <div class="row">
              <input type="number" id="frameWidthInput" placeholder="Width" value="200" />
              <input type="number" id="frameHeightInput" placeholder="Height" value="150" />
            </div>
          </div>
          <div id="framesList" class="list">
            <div class="hint">No frames created yet</div>
          </div>
        </div>

        <hr style="opacity:.06;border:none;height:1px;background:rgba(255,255,255,0.03)">

        <div>
          <label>Import / Export JSON</label>
          <textarea id="jsonBox" rows="6" placeholder='Paste JSON here or press "Export"'></textarea>
          <div class="row" style="margin-top:6px">
            <button id="exportBtn">Export</button>
            <button id="importBtn">Import</button>
          </div>
          <div class="row" style="margin-top:6px">
            <button id="loadRoomsBtn">Load rooms.json</button>
            <button id="exportForNavBtn">Export for Navigator</button>
          </div>
          <input type="file" id="roomsFileInput" accept=".json,application/json" style="display:none" />
        </div>

        <div>
          <label>Info / Path result</label>
          <div id="info" class="list">No path computed yet.</div>
        </div>

        <div style="display:flex;gap:8px">
          <button id="resetBtn" class="small">Reset all</button>
          <button id="zoomFitBtn" class="small">Fit view</button>
        </div>
      </div>
    </div>
  </div>

<script>
// Navigation Graph Editor with manual weight capabilities
// Data model: nodes: {id,x,y,name,longName}, edges: {from,to,weight}

const canvas = document.getElementById('graphCanvas');
const ctx = canvas.getContext('2d');
let DPR = window.devicePixelRatio || 1;
function resize() {
  const rect = canvas.getBoundingClientRect();
  canvas.width = Math.floor(rect.width * DPR);
  canvas.height = Math.floor(rect.height * DPR);
  ctx.setTransform(DPR,0,0,DPR,0,0);
  draw();
}
window.addEventListener('resize', resize);
window.addEventListener('orientationchange', resize);
window.addEventListener('load', resize);
requestAnimationFrame(resize);

// State
let nodes = [];
let edges = [];
let frames = [];
let frameIdCounter = 1;
let nodeIdCounter = 1;
let selected = new Set();
let dragging = null;
let dragOffset = {x:0,y:0};
let hovered = null;
let highlightedPath = {nodes:[], edges:[]};
let rightClickedEdge = null;
let selectedFrame = null;
let frameMode = 'select'; // 'select' or 'create'
    
    // Search functionality
    let searchTimeout = null;
    let searchResults = [];
    
    // DOM elements
const startNameInput = document.getElementById('startName');
const endNameInput = document.getElementById('endName');
const findPathBtn = document.getElementById('findPathBtn');
const infoBox = document.getElementById('info');
const selectedList = document.getElementById('selectedList');
const connectSelectedBtn = document.getElementById('connectSelectedBtn');
const removeSelectedBtn = document.getElementById('removeSelectedBtn');
const fromSelect = document.getElementById('fromSelect');
const toSelect = document.getElementById('toSelect');
const edgeWeightInput = document.getElementById('edgeWeight');
const connectBtn = document.getElementById('connectBtn');
const removeEdgeBtn = document.getElementById('removeEdgeBtn');
const jsonBox = document.getElementById('jsonBox');
const exportBtn = document.getElementById('exportBtn');
const importBtn = document.getElementById('importBtn');
const loadRoomsBtn = document.getElementById('loadRoomsBtn');
const exportForNavBtn = document.getElementById('exportForNavBtn');
const roomsFileInput = document.getElementById('roomsFileInput');
const resetBtn = document.getElementById('resetBtn');
const zoomFitBtn = document.getElementById('zoomFitBtn');
const clearHighlightBtn = document.getElementById('clearHighlightBtn');
const weightControls = document.getElementById('weightControls');
const createFrameBtn = document.getElementById('createFrameBtn');
const deleteFrameBtn = document.getElementById('deleteFrameBtn');
const frameNameInput = document.getElementById('frameNameInput');
const frameColorInput = document.getElementById('frameColorInput');
const frameWidthInput = document.getElementById('frameWidthInput');
const frameHeightInput = document.getElementById('frameHeightInput');
const framesList = document.getElementById('framesList');

// Frame button event listeners
createFrameBtn.addEventListener('click', createFrame);
deleteFrameBtn.addEventListener('click', deleteFrame);

// Helpers
function dist(a,b){ return Math.hypot(a.x-b.x, a.y-b.y); }
function getNodeAt(x,y){ for(let i=nodes.length-1;i>=0;i--){ const n=nodes[i]; if(Math.hypot(n.x-x,n.y-y) <= 16) return n; } return null }
function getFrameAt(x, y) {
    for (let i = frames.length - 1; i >= 0; i--) {
        const frame = frames[i];
        if (x >= frame.x && x <= frame.x + frame.width &&
            y >= frame.y && y <= frame.y + frame.height) {
            return frame;
        }
    }
    return null;
}

// Search functions
function searchNodes(query) {
    if (!query.trim()) {
        searchResults = [];
        updateSearchResults();
        return;
    }
    
    const searchTerm = query.toLowerCase();
    searchResults = nodes.filter(node => 
        node.name.toLowerCase().includes(searchTerm) ||
        node.longName.toLowerCase().includes(searchTerm) ||
        (node.building && node.building.toLowerCase().includes(searchTerm))
    );
    
    updateSearchResults();
}

function updateSearchResults() {
    const resultsContainer = document.getElementById('searchResults');
    resultsContainer.innerHTML = '';
    
    if (searchResults.length === 0) {
        resultsContainer.style.display = 'none';
        return;
    }
    
    resultsContainer.style.display = 'block';
    
    searchResults.forEach(node => {
        const resultItem = document.createElement('div');
        resultItem.className = 'search-result-item';
        resultItem.innerHTML = `
            <div class="search-result-name">${node.name}</div>
            <div class="search-result-building">${node.building || 'No building'}</div>
        `;
        
        resultItem.addEventListener('click', () => {
            selectNode(node.id);
            centerOnNode(node.id);
            document.getElementById('nodeSearch').value = '';
            resultsContainer.style.display = 'none';
        });
        
        resultsContainer.appendChild(resultItem);
    });
}

function centerOnNode(nodeId) {
    const node = nodes.find(n => n.id === nodeId);
    if (node) {
        // Center the view on the selected node
        const canvas = document.getElementById('graphCanvas');
        const centerX = canvas.width / 2;
        const centerY = canvas.height / 2;
        
        // Calculate offset to center the node
        const offsetX = centerX - node.x;
        const offsetY = centerY - node.y;
        
        // Apply offset to all nodes
        nodes.forEach(n => {
            n.x += offsetX;
            n.y += offsetY;
        });
        
        // Apply offset to all frames
        frames.forEach(f => {
            f.x += offsetX;
            f.y += offsetY;
        });
        
        draw();
    }
}

function selectNode(nodeId) {
    selectedNodes = [nodeId];
    updateSelectedNodesList();
    draw();
}

function getEdgeAt(x,y){ 
  for(let i=edges.length-1;i>=0;i--){ 
    const e = edges[i];
    const a = nodes.find(n=>n.id===e.from);
    const b = nodes.find(n=>n.id===e.to);
    if(!a || !b) continue;
    
    // Check if point is near line segment
    const A = x - a.x;
    const B = y - a.y;
    const C = b.x - a.x;
    const D = b.y - a.y;
    
    const dot = A * C + B * D;
    const lenSq = C * C + D * D;
    let param = -1;
    
    if (lenSq !== 0) param = dot / lenSq;
    
    let xx, yy;
    if (param < 0) {
      xx = a.x;
      yy = a.y;
    } else if (param > 1) {
      xx = b.x;
      yy = b.y;
    } else {
      xx = a.x + param * C;
      yy = a.y + param * D;
    }
    
    const dx = x - xx;
    const dy = y - yy;
    const distance = Math.sqrt(dx * dx + dy * dy);
    
    if (distance <= 8) return e;
  }
  return null;
}

function addNode(x,y,name,longName){ 
  const n={id:nodeIdCounter++,x,y,name: name||('Room '+(nodeIdCounter-1)), longName: (longName && String(longName).trim()) || (name && String(name).trim()) || ('Room '+(nodeIdCounter-1))}; 
  nodes.push(n); 
  rebuildSelects(); 
  draw(); 
  return n; 
}

function removeNode(node){ 
  nodes = nodes.filter(n=>n.id!==node.id); 
  edges = edges.filter(e=>e.from!==node.id && e.to!==node.id); 
  selected.delete(node.id); 
  rebuildSelects(); 
  draw(); 
}

function addEdge(aId,bId,w){ 
  if(aId===bId) return; // no self-edge
  // avoid duplicate undirected edges
  const exists = edges.find(e => (e.from===aId && e.to===bId) || (e.from===bId && e.to===aId));
  if(exists) return;
  const a = nodes.find(n=>n.id===aId), b = nodes.find(n=>n.id===bId);
  const weight = (w!==undefined && w!==null && w!=='') ? Number(w) : Math.round(dist(a,b));
  edges.push({from:aId,to:bId,weight}); 
  draw(); 
}

function removeEdgeBetween(aId,bId){ 
  edges = edges.filter(e=>!((e.from===aId&&e.to===bId)||(e.from===bId&&e.to===aId))); 
  draw(); 
}

function updateEdgeWeight(edge, newWeight) {
  if (edge && newWeight !== undefined && newWeight !== null && newWeight !== '') {
    edge.weight = Number(newWeight);
    draw();
    updateWeightControls();
  }
}

function rebuildSelects(){ 
  fromSelect.innerHTML=''; 
  toSelect.innerHTML='';
  for(const n of nodes){ 
    const opt=document.createElement('option'); 
    opt.value=n.id; 
    opt.textContent=n.name||('Room '+n.id); 
    fromSelect.appendChild(opt.cloneNode(true)); 
    toSelect.appendChild(opt.cloneNode(true)); 
  }
  updateSelectedList(); 
}

function updateSelectedList(){ 
  if(selected.size===0){ 
    selectedList.innerHTML='(none)'; 
    return; 
  }
  selectedList.innerHTML = Array.from(selected).map(id=>{ 
    const n=nodes.find(x=>x.id===id); 
    const label = n.longName || n.name; 
    return `<div>${label} <small style="color:var(--muted)">(id:${n.id})</small></div>` 
  }).join(''); 
}

function updateWeightControls() {
  if (rightClickedEdge) {
    const fromNode = nodes.find(n => n.id === rightClickedEdge.from);
    const toNode = nodes.find(n => n.id === rightClickedEdge.to);
    weightControls.innerHTML = `
      <div class="weight-row">
        <label>${fromNode?.name || rightClickedEdge.from} → ${toNode?.name || rightClickedEdge.to}</label>
      </div>
      <div class="weight-row">
        <input type="number" id="weightInput" value="${rightClickedEdge.weight}" placeholder="Weight" />
        <button id="updateWeightBtn">Update</button>
        <button id="resetWeightBtn">Reset</button>
      </div>
    `;
    
    // Add event listeners
    document.getElementById('updateWeightBtn')?.addEventListener('click', () => {
      const newWeight = document.getElementById('weightInput').value;
      updateEdgeWeight(rightClickedEdge, newWeight);
    });
    
    document.getElementById('resetWeightBtn')?.addEventListener('click', () => {
      const fromNode = nodes.find(n => n.id === rightClickedEdge.from);
      const toNode = nodes.find(n => n.id === rightClickedEdge.to);
      if (fromNode && toNode) {
        rightClickedEdge.weight = Math.round(dist(fromNode, toNode));
        draw();
        updateWeightControls();
      }
    });
  } else {
    weightControls.innerHTML = '<div class="hint">Right-click on an edge to edit its weight</div>';
  }
}

// Frame functions
function createFrame() {
  const name = frameNameInput.value.trim();
  const color = frameColorInput.value;
  const width = Number(frameWidthInput.value) || 200;
  const height = Number(frameHeightInput.value) || 150;
  
  if (!name) {
    alert('Please enter a frame name');
    return;
  }
  
  const frame = {
    id: frameIdCounter++,
    name: name,
    color: color,
    nodes: [],
    x: 100,
    y: 100,
    width: width,
    height: height
  };
  
  frames.push(frame);
  updateFramesList();
  draw();
}

function deleteFrame() {
  if (selectedFrame) {
    frames = frames.filter(f => f.id !== selectedFrame.id);
    selectedFrame = null;
    updateFramesList();
    draw();
  } else {
    alert('Please select a frame to delete');
  }
}

function updateFramesList() {
  if (frames.length === 0) {
    framesList.innerHTML = '<div class="hint">No frames created yet</div>';
    return;
  }
  
  framesList.innerHTML = frames.map(frame => `
    <div class="frame-item" data-frame-id="${frame.id}" style="cursor: pointer; padding: 4px; border-radius: 4px; margin-bottom: 4px; background: ${frame.color}20; border: 1px solid ${frame.color}40;">
      <div style="font-weight: bold; color: ${frame.color}">${frame.name}</div>
      <div style="font-size: 11px; color: var(--muted)">${frame.nodes.length} nodes</div>
    </div>
  `).join('');
  
  // Add click handlers
  framesList.querySelectorAll('.frame-item').forEach(item => {
    item.addEventListener('click', () => {
      const frameId = Number(item.dataset.frameId);
      selectedFrame = frames.find(f => f.id === frameId);
      draw();
    });
  });
}

function addNodeToFrame(nodeId, frameId) {
  const frame = frames.find(f => f.id === frameId);
  const node = nodes.find(n => n.id === nodeId);
  
  if (frame && node && !frame.nodes.includes(nodeId)) {
    frame.nodes.push(nodeId);
    updateFramesList();
    draw();
  }
}

function removeNodeFromFrame(nodeId, frameId) {
  const frame = frames.find(f => f.id === frameId);
  if (frame) {
    frame.nodes = frame.nodes.filter(id => id !== nodeId);
    updateFramesList();
    draw();
  }
}

// Drawing
function draw(){ 
  ctx.clearRect(0,0,canvas.width/DPR,canvas.height/DPR);
  
  // Draw frames first (background)
  for (const frame of frames) {
    ctx.fillStyle = frame.color + '10';
    ctx.strokeStyle = frame.color + '60';
    ctx.lineWidth = 2;
    ctx.setLineDash([5, 5]);
    
    ctx.beginPath();
    ctx.rect(frame.x, frame.y, frame.width, frame.height);
    ctx.fill();
    ctx.stroke();
    
    // Frame label
    ctx.fillStyle = frame.color;
    ctx.font = '12px sans-serif';
    ctx.textAlign = 'left';
    ctx.textBaseline = 'top';
    ctx.fillText(frame.name, frame.x + 8, frame.y + 8);
    
    // Highlight selected frame
    if (selectedFrame && selectedFrame.id === frame.id) {
      ctx.strokeStyle = frame.color;
      ctx.lineWidth = 3;
      ctx.setLineDash([]);
      ctx.stroke();
    }
  }
  
  // Reset line dash
  ctx.setLineDash([]);
  
  // edges
  for(const e of edges){ 
    const a = nodes.find(n=>n.id===e.from); 
    const b = nodes.find(n=>n.id===e.to);
    if (!a || !b) continue;
    
    const isHighlighted = highlightedPath.edges.some(p=> (p.from===e.from && p.to===e.to) || (p.from===e.to && p.to===e.from));
    const isRightClicked = rightClickedEdge && ((e.from === rightClickedEdge.from && e.to === rightClickedEdge.to) || (e.from === rightClickedEdge.to && e.to === rightClickedEdge.from));
    
    ctx.lineWidth = isHighlighted ? 4 : (isRightClicked ? 3 : 2);
    ctx.strokeStyle = isHighlighted ? '#34d399' : (isRightClicked ? '#06b6d4' : 'rgba(255,255,255,0.12)');
    ctx.beginPath(); 
    ctx.moveTo(a.x,a.y); 
    ctx.lineTo(b.x,b.y); 
    ctx.stroke();
    
    // weight label
    const mx=(a.x+b.x)/2, my=(a.y+b.y)/2;
    ctx.fillStyle = 'rgba(255,255,255,0.7)'; 
    ctx.font='12px sans-serif'; 
    ctx.fillText(e.weight, mx+6, my-6);
  }
  
  // nodes
  for(const n of nodes){ 
    const isSel = selected.has(n.id); 
    const isHover = hovered && hovered.id===n.id;
    ctx.beginPath(); 
    ctx.arc(n.x,n.y,16,0,Math.PI*2);
    ctx.fillStyle = isSel ? '#06b6d4' : (isHover ? 'rgba(6,182,212,0.6)' : 'rgba(255,255,255,0.15)');
    ctx.fill();
    ctx.strokeStyle = isSel ? '#38bdf8' : 'rgba(0,0,0,0)';
    ctx.lineWidth = isSel ? 3 : 0;
    ctx.stroke();
    ctx.fillStyle = '#e6eef6';
    ctx.font = '12px sans-serif';
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';
    const label = isSel ? (n.longName || n.name) : n.name;
    ctx.fillText(label, n.x, n.y);
  }
}

// Interaction
canvas.addEventListener('mousedown', e=>{
  const rect = canvas.getBoundingClientRect();
  const x = (e.clientX - rect.left);
  const y = (e.clientY - rect.top);
  
  // Check if clicking on a frame first
  const clickedFrame = getFrameAt(x, y);
  if (clickedFrame) {
    if (e.shiftKey) {
      // Shift+click to add/remove nodes from frame
      const node = getNodeAt(x, y);
      if (node) {
        if (clickedFrame.nodes.includes(node.id)) {
          removeNodeFromFrame(node.id, clickedFrame.id);
        } else {
          addNodeToFrame(node.id, clickedFrame.id);
        }
      }
    } else {
      // Regular click to select frame and start dragging
      selectedFrame = clickedFrame;
      dragging = { type: 'frame', frame: clickedFrame };
      dragOffset.x = x - clickedFrame.x;
      dragOffset.y = y - clickedFrame.y;
      draw();
      return;
    }
  }
  
  const node = getNodeAt(x,y);
  if(node){
    dragging = { type: 'node', node: node };
    dragOffset.x = x - node.x;
    dragOffset.y = y - node.y;
  }
});

canvas.addEventListener('mouseup', e=>{
  if (dragging && dragging.type === 'frame') {
    selectedFrame = dragging.frame;
  }
  dragging = null;
});

canvas.addEventListener('mousemove', e=>{
  const rect = canvas.getBoundingClientRect();
  const x = (e.clientX - rect.left);
  const y = (e.clientY - rect.top);

  if(dragging){
    if (dragging.type === 'frame') {
      dragging.frame.x = x - dragOffset.x;
      dragging.frame.y = y - dragOffset.y;
    } else if (dragging.type === 'node') {
      dragging.node.x = x - dragOffset.x;
      dragging.node.y = y - dragOffset.y;
    }
    draw();
    return;
  }

  // hover detection
  const node = getNodeAt(x,y);
  if(node !== hovered){
    hovered = node;
    draw();
  }
});

canvas.addEventListener('click', e=>{
  const rect = canvas.getBoundingClientRect();
  const x = (e.clientX - rect.left);
  const y = (e.clientY - rect.top);
  const node = getNodeAt(x,y);

  if(node){
    if(e.shiftKey){
      if(selected.has(node.id)) selected.delete(node.id);
      else selected.add(node.id);
      updateSelectedList();
      draw();
    } else {
      selected.clear();
      selected.add(node.id);
      updateSelectedList();
      draw();
    }
  } else {
    // Clicked empty space → add new node
    const name = prompt('Enter room name:');
    const finalName = (name && name.trim()) ? name.trim() : ('Room ' + nodeIdCounter);
    addNode(x, y, finalName, finalName);
  }
});

canvas.addEventListener('contextmenu', e => {
  e.preventDefault();
  const rect = canvas.getBoundingClientRect();
  const x = (e.clientX - rect.left);
  const y = (e.clientY - rect.top);
  const edge = getEdgeAt(x, y);
  
  if (edge) {
    rightClickedEdge = edge;
    updateWeightControls();
    draw();
  } else {
    rightClickedEdge = null;
    updateWeightControls();
    draw();
  }
});

// Buttons
connectSelectedBtn.addEventListener('click', () => {
  if(selected.size !== 2) {
    alert('Select exactly two nodes with Shift+Click');
    return;
  }
  const [a,b] = Array.from(selected);
  addEdge(a,b);
});

removeSelectedBtn.addEventListener('click', () => {
  Array.from(selected).forEach(id => {
    const node = nodes.find(n=>n.id===id);
    if(node) removeNode(node);
  });
  selected.clear();
  updateSelectedList();
  draw();
});

connectBtn.addEventListener('click', () => {
  const fromId = Number(fromSelect.value);
  const toId = Number(toSelect.value);
  const w = edgeWeightInput.value;
  addEdge(fromId,toId,w);
});

removeEdgeBtn.addEventListener('click', () => {
  const fromId = Number(fromSelect.value);
  const toId = Number(toSelect.value);
  removeEdgeBetween(fromId,toId);
});

exportBtn.addEventListener('click', () => {
  const data = {nodes, edges, frames};
  jsonBox.value = JSON.stringify(data, null, 2);
});

importBtn.addEventListener('click', () => {
  try {
    const data = JSON.parse(jsonBox.value);
    if(Array.isArray(data.nodes) && Array.isArray(data.edges)){
      nodes = data.nodes.map(n => ({...n}));
      edges = data.edges.map(e => ({...e}));
      frames = data.frames ? data.frames.map(f => ({...f})) : [];
      nodeIdCounter = nodes.reduce((max, n) => Math.max(max, n.id), 0) + 1;
      frameIdCounter = frames.reduce((max, f) => Math.max(max, f.id), 0) + 1;
      selected.clear();
      selectedFrame = null;
      highlightedPath.nodes = [];
      highlightedPath.edges = [];
      rightClickedEdge = null;
      rebuildSelects();
      updateWeightControls();
      updateFramesList();
      draw();
      infoBox.textContent = 'Data imported successfully.';
    } else {
      alert('Invalid JSON format');
    }
  } catch(e){
    alert('Invalid JSON');
  }
});

exportForNavBtn.addEventListener('click', () => {
  const data = {nodes, edges, frames};
  const blob = new Blob([JSON.stringify(data, null, 2)], {type: 'application/json'});
  const url = URL.createObjectURL(blob);
  const a = document.createElement('a');
  a.href = url;
  a.download = 'navigation-graph.json';
  a.click();
  URL.revokeObjectURL(url);
  infoBox.textContent = 'Graph exported for navigator.';
});

// Load rooms.json → import as nodes without connections
async function loadRoomsJson(){
  roomsFileInput.click();
}

function importRoomsFromArray(arr){
  if(!Array.isArray(arr) || arr.length===0){
    infoBox.textContent = 'rooms.json: no rooms found.';
    return;
  }
  // Reset graph state
  nodes = [];
  edges = [];
  selected.clear();
  highlightedPath.nodes = [];
  highlightedPath.edges = [];
  rightClickedEdge = null;
  nodeIdCounter = 1;

  // Layout positions if x/y missing
  const rect = canvas.getBoundingClientRect();
  const width = rect.width || 800;
  const height = rect.height || 600;
  const count = arr.length;
  const cols = Math.ceil(Math.sqrt(count));
  const rows = Math.ceil(count / cols);
  const padding = 48;
  const cellW = Math.max(1, (width - padding*2) / cols);
  const cellH = Math.max(1, (height - padding*2) / rows);

  let i = 0;
  for(const item of arr){
    const name = (item && item.name) ? String(item.name) : ('Room ' + (i+1));
    const longName = (item && (item.longName || item.longname || item.fullName || item.title)) ? String(item.longName || item.longname || item.fullName || item.title) : name;
    let x = Number(item && item.x);
    let y = Number(item && item.y);
    if(!Number.isFinite(x) || !Number.isFinite(y)){
      const c = i % cols;
      const r = Math.floor(i / cols);
      x = Math.round(padding + c*cellW + cellW/2);
      y = Math.round(padding + r*cellH + cellH/2);
    }
    addNode(x, y, name, longName);
    i++;
  }
  infoBox.textContent = `Loaded ${count} rooms from rooms.json.`;
  rebuildSelects();
  updateWeightControls();
  draw();
}

loadRoomsBtn.addEventListener('click', () => {
  loadRoomsJson();
});

resetBtn.addEventListener('click', () => {
  if(confirm('Reset all nodes, edges, and frames?')){
    nodes = [];
    edges = [];
    frames = [];
    selected.clear();
    highlightedPath.nodes = [];
    highlightedPath.edges = [];
    rightClickedEdge = null;
    nodeIdCounter = 1;
    rebuildSelects();
    updateWeightControls();
    draw();
    infoBox.textContent = 'Reset done.';
  }
});

clearHighlightBtn.addEventListener('click', () => {
  highlightedPath.nodes = [];
  highlightedPath.edges = [];
  infoBox.textContent = 'Highlight cleared.';
  draw();
});

zoomFitBtn.addEventListener('click', () => {
  if (nodes.length === 0) {
    alert('No nodes to fit to view.');
    return;
  }
  
  const minX = Math.min(...nodes.map(n => n.x));
  const maxX = Math.max(...nodes.map(n => n.x));
  const minY = Math.min(...nodes.map(n => n.y));
  const maxY = Math.max(...nodes.map(n => n.y));
  
  const padding = 100;
  const scaleX = (canvas.width/DPR - padding*2) / (maxX - minX);
  const scaleY = (canvas.height/DPR - padding*2) / (maxY - minY);
  const scale = Math.min(scaleX, scaleY, 1);
  
  // Center the view
  const centerX = (minX + maxX) / 2;
  const centerY = (minY + maxY) / 2;
  
  // Apply transformation
  ctx.save();
  ctx.translate(canvas.width/DPR/2, canvas.height/DPR/2);
  ctx.scale(scale, scale);
  ctx.translate(-centerX, -centerY);
  
  infoBox.textContent = 'View fitted to nodes.';
});

// Dijkstra shortest path
function findShortestPath(startName, endName){
  const startNode = nodes.find(n=>n.name.toLowerCase() === startName.toLowerCase());
  const endNode = nodes.find(n=>n.name.toLowerCase() === endName.toLowerCase());
  if(!startNode || !endNode){
    infoBox.textContent = 'Start or end room not found.';
    return;
  }
  // Dijkstra's algorithm
  const distMap = new Map();
  const prevMap = new Map();
  const Q = new Set(nodes.map(n=>n.id));
  nodes.forEach(n=>distMap.set(n.id, Infinity));
  distMap.set(startNode.id, 0);

  while(Q.size){
    // node in Q with smallest dist
    let u = null, uDist = Infinity;
    for(const id of Q){
      const d = distMap.get(id);
      if(d < uDist){ u = id; uDist = d; }
    }
    if(u === null) break;
    Q.delete(u);
    if(u === endNode.id) break;

    const neighbors = edges.filter(e => e.from === u || e.to === u);
    for(const e of neighbors){
      const v = (e.from === u) ? e.to : e.from;
      if(!Q.has(v)) continue;
      const alt = distMap.get(u) + e.weight;
      if(alt < distMap.get(v)){
        distMap.set(v, alt);
        prevMap.set(v, u);
      }
    }
  }

  // reconstruct path
  const pathNodes = [];
  const pathEdges = [];
  let current = endNode.id;
  while(current !== undefined && current !== startNode.id){
    pathNodes.unshift(current);
    const prev = prevMap.get(current);
    if(prev !== undefined){
      pathEdges.unshift({from: prev, to: current});
    }
    current = prev;
  }
  if(current === startNode.id) pathNodes.unshift(startNode.id);
  else {
    infoBox.textContent = 'No path found.';
    highlightedPath.nodes = [];
    highlightedPath.edges = [];
    draw();
    return;
  }

  highlightedPath.nodes = pathNodes;
  highlightedPath.edges = pathEdges;
  infoBox.textContent = `Shortest path found (${distMap.get(endNode.id)} units)`;
  draw();
}

findPathBtn.addEventListener('click', () => {
  findShortestPath(startNameInput.value.trim(), endNameInput.value.trim());
});

roomsFileInput.addEventListener('change', (e) => {
  const file = e.target.files && e.target.files[0];
  if(!file) return;
  const reader = new FileReader();
  reader.onload = () => {
    try{
      const data = JSON.parse(String(reader.result));
      const roomsArray = Array.isArray(data) ? data : (Array.isArray(data.rooms) ? data.rooms : null);
      if(!roomsArray){
        infoBox.textContent = 'rooms.json format unsupported. Use an array or {"rooms": [...] }';
        return;
      }
      const normalized = roomsArray.map((r,i)=>{
        if(typeof r === 'string') return { name: r };
        if(r && typeof r === 'object') return r;
        return { name: 'Room ' + (i+1) };
      });
      importRoomsFromArray(normalized);
      roomsFileInput.value = '';
    } catch(err){
      console.error(err);
      alert('Invalid JSON in selected file.');
    }
  };
  reader.onerror = () => {
    alert('Failed to read file.');
  };
  reader.readAsText(file);
});

// Search input event listener
document.getElementById('nodeSearch').addEventListener('input', (e) => {
    clearTimeout(searchTimeout);
    searchTimeout = setTimeout(() => {
        searchNodes(e.target.value);
    }, 300);
});

// Close search results when clicking outside
document.addEventListener('click', (e) => {
    const searchContainer = document.querySelector('.search-container');
    if (!searchContainer.contains(e.target)) {
        document.getElementById('searchResults').style.display = 'none';
    }
});

// Initialize
updateWeightControls();
</script>
</body>
</html> 