<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Navigation Graph Editor</title>
  <style>
    :root {
      --bg: #000000;
      --panel: #111111;
      --muted: #888888;
      --accent: #ffffff;
      --success: #ffffff;
      --border: #333333;
      --hover: #1a1a1a;
    }
    
    html, body {
      height: 100%;
      margin: 0;
      font-family: 'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
      background: var(--bg);
      color: var(--accent);
    }
    
    .app {
      display: flex;
      gap: 12px;
      height: 100%;
      padding: 12px;
      box-sizing: border-box;
    }
    
    .canvas-wrap {
      flex: 1;
      background: var(--panel);
      border-radius: 12px;
      padding: 12px;
      display: flex;
      flex-direction: column;
      position: relative;
      overflow: hidden;
    }
    
    canvas {
      background: transparent;
      border-radius: 8px;
      flex: 1;
      cursor: crosshair;
    }
    
    .panel {
      width: 400px;
      background: var(--panel);
      border-radius: 12px;
      padding: 12px;
      box-shadow: 0 6px 30px rgba(0, 0, 0, 0.6);
      border: 1px solid var(--border);
      display: flex;
      flex-direction: column;
      overflow-y: auto;
      max-height: 100%;
    }
    
    h1 {
      margin: 4px 0 10px;
      font-size: 18px;
      color: var(--accent);
    }
    
    .section {
      margin-bottom: 20px;
      padding: 16px;
      background: var(--hover);
      border-radius: 8px;
      border: 1px solid var(--border);
    }
    
    .section h3 {
      margin: 0 0 12px 0;
      font-size: 14px;
      color: var(--accent);
    }
    
    .controls {
      display: grid;
      gap: 8px;
    }
    
    label {
      font-size: 12px;
      color: var(--muted);
      margin-bottom: 4px;
      display: block;
    }
    
    input, select, button, textarea {
      width: 100%;
      padding: 8px 12px;
      margin: 4px 0;
      border: 1px solid var(--border);
      border-radius: 6px;
      background: var(--panel);
      color: var(--accent);
      font-size: 14px;
      box-sizing: border-box;
    }
    
    input:focus, select:focus, textarea:focus {
      outline: none;
      border-color: var(--accent);
    }
    
    select option {
      background: var(--panel);
      color: var(--accent);
      padding: 8px;
    }
    
    button {
      background: var(--accent);
      color: var(--bg);
      cursor: pointer;
      font-weight: 600;
      transition: all 0.2s ease;
    }
    
    button:hover {
      background: #f0f0f0;
      transform: translateY(-1px);
    }
    
    button:disabled {
      background: var(--muted);
      color: var(--bg);
      cursor: not-allowed;
      transform: none;
    }
    
    .row {
      display: flex;
      gap: 8px;
    }
    
    .row > * {
      flex: 1;
    }
    
    .small {
      font-size: 12px;
      padding: 6px 12px;
    }
    
    .list {
      max-height: 160px;
      overflow: auto;
      background: var(--panel);
      padding: 8px;
      border-radius: 6px;
      border: 1px solid var(--border);
    }
    
    .hint {
      font-size: 12px;
      color: var(--muted);
      margin: 8px 0;
    }
    
    .toolbar {
      display: flex;
      gap: 8px;
      margin-bottom: 8px;
      flex-wrap: wrap;
    }
    
    .node-badge {
      display: inline-block;
      padding: 6px 8px;
      border-radius: 6px;
      background: var(--panel);
      border: 1px solid var(--border);
      font-size: 12px;
      color: var(--accent);
      margin: 2px;
    }
    
    .tag-badge {
      display: inline-block;
      padding: 4px 8px;
      border-radius: 12px;
      background: var(--accent);
      color: var(--bg);
      font-size: 11px;
      font-weight: 600;
      margin: 2px;
    }
    
    .tag-section {
      margin-bottom: 16px;
    }
    
    .tag-section label {
      margin-bottom: 8px;
    }
    
    .weight-controls {
      background: var(--panel);
      padding: 12px;
      border-radius: 6px;
      margin-top: 8px;
      border: 1px solid var(--border);
    }
    
    .weight-row {
      display: flex;
      gap: 8px;
      align-items: center;
      margin-bottom: 8px;
    }
    
    .weight-row input {
      flex: 1;
    }
    
    .weight-row button {
      flex-shrink: 0;
      padding: 4px 8px;
      font-size: 11px;
    }
    
    .frame-item {
      cursor: pointer;
      padding: 8px;
      border-radius: 6px;
      margin-bottom: 8px;
      border: 1px solid var(--border);
      transition: all 0.2s ease;
    }
    
    .frame-item:hover {
      background: var(--hover) !important;
      transform: translateY(-1px);
    }
    
    hr {
      opacity: 0.2;
      border: none;
      height: 1px;
      background: var(--border);
      margin: 16px 0;
    }
    
    /* Search Bar Styles */
    .search-container {
      position: absolute;
      top: 20px;
      right: 20px;
      z-index: 1000;
      width: 250px;
    }
    
    .search-input {
      width: 100%;
      padding: 8px 12px;
      border: 1px solid var(--border);
      border-radius: 6px;
      background: var(--panel);
      color: var(--accent);
      font-size: 14px;
      box-sizing: border-box;
    }
    
    .search-input:focus {
      outline: none;
      border-color: var(--accent);
    }
    
    .search-results {
      position: absolute;
      top: 100%;
      left: 0;
      right: 0;
      background: var(--panel);
      border: 1px solid var(--border);
      border-radius: 6px;
      max-height: 200px;
      overflow-y: auto;
      z-index: 1001;
      display: none;
    }
    
    .search-result-item {
      padding: 8px 12px;
      cursor: pointer;
      border-bottom: 1px solid var(--border);
      transition: background 0.2s ease;
    }
    
    .search-result-item:hover {
      background: var(--hover);
    }
    
    .search-result-item:last-child {
      border-bottom: none;
    }
    
    .search-result-item .node-name {
      font-weight: 600;
      color: var(--accent);
    }
    
    .search-result-item .node-details {
      font-size: 12px;
      color: var(--muted);
      margin-top: 2px;
    }
  </style>
</head>
<body>
  <div class="app">
    <div class="canvas-wrap">
      <div class="toolbar">
        <div class="node-badge">Click canvas to add a room</div>
        <div class="node-badge">Drag nodes to reposition</div>
        <div class="node-badge">Shift+Click two nodes to select them, then Connect</div>
        <div class="node-badge">Right-click edges to edit weights</div>
        <div class="node-badge" id="gridIndicator" style="display: none;">Grid snapping active (Ctrl)</div>
      </div>
      <canvas id="graphCanvas"></canvas>
      
      <!-- Node Search Bar -->
      <div class="search-container">
          <input type="text" id="nodeSearch" placeholder="Search nodes..." class="search-input">
          <div id="searchResults" class="search-results"></div>
      </div>
      
      <div class="hint">Left-click canvas: add node â€¢ Click node: select â€¢ Drag node: move â€¢ Shift+click: multi-select â€¢ Right-click edge: edit weight â€¢ Middle-drag: pan canvas â€¢ Scroll: zoom â€¢ Ctrl+Z: undo â€¢ F2: rename â€¢ Ctrl+drag: grid snap â€¢ Del: delete selected nodes/frames/edges</div>
    </div>

    <div class="panel">
      <h1>Navigation Graph Editor</h1>
      
      <!-- Node Selection -->
      <div class="section">
        <h3>Node Selection</h3>
        <div class="controls">
          <div>
            <label>Selected nodes (click nodes in canvas)</label>
            <div id="selectedList" class="list">(none)</div>
          </div>
          <div class="row">
            <button id="connectSelectedBtn">Connect selected</button>
            <button id="removeSelectedBtn">Remove selected</button>
          </div>
        </div>
      </div>

      <!-- Manual Connection -->
      <div class="section">
        <h3>Manual Connection</h3>
        <div class="controls">
          <div>
            <label>Connect manually (from â†’ to)</label>
            <div class="row">
              <select id="fromSelect"></select>
              <select id="toSelect"></select>
            </div>
            <label style="margin-top:6px">Weight (leave empty to auto distance)</label>
            <input id="edgeWeight" placeholder="auto" />
            <div class="row" style="margin-top:6px">
              <button id="connectBtn">Connect</button>
              <button id="removeEdgeBtn">Remove edge</button>
            </div>
          </div>
        </div>
      </div>

      <!-- Edge Weight Editor -->
      <div class="section">
        <h3>Edge Weight Editor</h3>
        <div class="weight-controls">
          <div id="weightControls">
            <div class="hint">Right-click on an edge to edit its weight</div>
          </div>
        </div>
      </div>

      <!-- Tag Editor -->
      <div class="section">
        <h3>Tag Editor</h3>
        <div class="controls">
          <div class="tag-section">
            <label>Add tag to selected nodes</label>
            <div class="row">
              <input id="tagInput" placeholder="Enter tag name" />
              <button id="addTagBtn">Add</button>
            </div>
          </div>
          <div class="tag-section">
            <label>Remove tag from selected nodes</label>
            <div class="row">
              <select id="tagRemoveSelect">
                <option value="">Select tag to remove</option>
              </select>
              <button id="removeTagBtn">Remove</button>
            </div>
          </div>
          <div class="tag-section">
            <label>Selected nodes tags</label>
            <div id="selectedTagsList" class="list">(none selected)</div>
          </div>
        </div>
      </div>

      <!-- Frame Management -->
      <div class="section">
        <h3>Frame Management</h3>
        <div class="controls">
          <div class="row">
            <button id="createFrameBtn">Create Frame</button>
            <button id="deleteFrameBtn">Delete Frame</button>
          </div>
          <div>
            <label>Frame name</label>
            <input id="frameNameInput" placeholder="e.g. Building A, Floor 1" />
          </div>
          <div>
            <label>Frame color</label>
            <input type="color" id="frameColorInput" value="#3b82f6" />
          </div>
          <div>
            <label>Frame size</label>
            <div class="row">
              <input type="number" id="frameWidthInput" placeholder="Width" value="200" />
              <input type="number" id="frameHeightInput" placeholder="Height" value="150" />
            </div>
          </div>
          <div>
            <label>Background Image (optional)</label>
            <div class="row">
              <input type="file" id="frameBackgroundInput" accept="image/*" style="flex: 1;" />
              <button id="clearBackgroundBtn" class="small">Clear</button>
            </div>
          </div>
          <div id="framesList" class="list">
            <div class="hint">No frames created yet</div>
          </div>
        </div>
      </div>

      <!-- Import / Export -->
      <div class="section">
        <h3>Import / Export JSON</h3>
        <div class="controls">
          <textarea id="jsonBox" rows="6" placeholder='Paste JSON here or press "Export"'></textarea>
          <div class="row" style="margin-top:6px">
            <button id="exportBtn">Export</button>
            <button id="importBtn">Import</button>
          </div>
          <div class="row" style="margin-top:6px">
            <button id="loadRoomsBtn">Load rooms.json</button>
            <button id="exportForNavBtn">Export for Navigator</button>
          </div>
          <input type="file" id="roomsFileInput" accept=".json,application/json" style="display:none" />
        </div>
      </div>

      <!-- Path Finding -->
      <div class="section">
        <h3>Path Finder</h3>
        <div class="controls">
          <div>
            <label>Start room name</label>
            <input id="startName" placeholder="e.g. Room A" />
          </div>
          <div>
            <label>End room name</label>
            <input id="endName" placeholder="e.g. Room B" />
          </div>
          <div class="row">
            <button id="findPathBtn">Find shortest path</button>
            <button id="clearHighlightBtn">Clear highlight</button>
          </div>
        </div>
      </div>

      <!-- Info / Results -->
      <div class="section">
        <h3>Info / Path Results</h3>
        <div class="controls">
          <div id="info" class="list">No path computed yet.</div>
          <div style="display:flex;gap:8px;margin-top:8px">
            <button id="resetBtn" class="small">Reset all</button>
            <button id="zoomFitBtn" class="small">Fit view</button>
          </div>
        </div>
      </div>
    </div>
  </div>

<script>
// Navigation Graph Editor with manual weight capabilities
// Data model: nodes: {id,x,y,name,longName}, edges: {from,to,weight}

const canvas = document.getElementById('graphCanvas');
const ctx = canvas.getContext('2d');
let DPR = window.devicePixelRatio || 1;
function resize() {
  const rect = canvas.getBoundingClientRect();
  canvas.width = Math.floor(rect.width * DPR);
  canvas.height = Math.floor(rect.height * DPR);
  ctx.setTransform(DPR,0,0,DPR,0,0);
  draw();
}
window.addEventListener('resize', resize);
window.addEventListener('orientationchange', resize);
window.addEventListener('load', resize);
requestAnimationFrame(resize);

// State
let nodes = [];
let edges = [];
let frames = [];
let selected = new Set();
let selectedFrame = null;
let rightClickedEdge = null;
let highlightedPath = {nodes: [], edges: []};
let hovered = null;
let dragging = null;
let dragOffset = {x: 0, y: 0};

// View transformation
let viewX = 0;
let viewY = 0;
let viewScale = 1;
let isPanning = false;
let lastMousePos = {x: 0, y: 0};

// Counters
let nodeIdCounter = 1;
let frameIdCounter = 1;

// Image cache for background images
let imageCache = new Map();

// Undo/Redo system
let undoStack = [];
let redoStack = [];
let isUndoRedoAction = false;

// Grid snapping
const GRID_SIZE =5;
let isCtrlPressed = false;

// Search functionality
let searchTimeout = null;
let searchResults = [];
    
    // DOM elements
const startNameInput = document.getElementById('startName');
const endNameInput = document.getElementById('endName');
const findPathBtn = document.getElementById('findPathBtn');
const infoBox = document.getElementById('info');
const selectedList = document.getElementById('selectedList');
const connectSelectedBtn = document.getElementById('connectSelectedBtn');
const removeSelectedBtn = document.getElementById('removeSelectedBtn');
const fromSelect = document.getElementById('fromSelect');
const toSelect = document.getElementById('toSelect');
const edgeWeightInput = document.getElementById('edgeWeight');
const connectBtn = document.getElementById('connectBtn');
const removeEdgeBtn = document.getElementById('removeEdgeBtn');
const jsonBox = document.getElementById('jsonBox');
const exportBtn = document.getElementById('exportBtn');
const importBtn = document.getElementById('importBtn');
const loadRoomsBtn = document.getElementById('loadRoomsBtn');
const exportForNavBtn = document.getElementById('exportForNavBtn');
const roomsFileInput = document.getElementById('roomsFileInput');
const resetBtn = document.getElementById('resetBtn');
const zoomFitBtn = document.getElementById('zoomFitBtn');
const clearHighlightBtn = document.getElementById('clearHighlightBtn');
const weightControls = document.getElementById('weightControls');
const createFrameBtn = document.getElementById('createFrameBtn');
const deleteFrameBtn = document.getElementById('deleteFrameBtn');
const frameNameInput = document.getElementById('frameNameInput');
const frameColorInput = document.getElementById('frameColorInput');
const frameWidthInput = document.getElementById('frameWidthInput');
const frameHeightInput = document.getElementById('frameHeightInput');
const framesList = document.getElementById('framesList');
const frameBackgroundInput = document.getElementById('frameBackgroundInput');
const clearBackgroundBtn = document.getElementById('clearBackgroundBtn');

// Tag editor elements
const tagInput = document.getElementById('tagInput');
const addTagBtn = document.getElementById('addTagBtn');
const tagRemoveSelect = document.getElementById('tagRemoveSelect');
const removeTagBtn = document.getElementById('removeTagBtn');
const selectedTagsList = document.getElementById('selectedTagsList');

// Frame button event listeners
createFrameBtn.addEventListener('click', createFrame);
deleteFrameBtn.addEventListener('click', deleteFrame);

// Background image event listeners
frameBackgroundInput.addEventListener('change', handleBackgroundImageUpload);
clearBackgroundBtn.addEventListener('click', clearBackgroundImage);

// Tag editor event listeners
addTagBtn.addEventListener('click', addTagToSelected);
removeTagBtn.addEventListener('click', removeTagFromSelected);

// Helpers
function dist(a,b){ return Math.hypot(a.x-b.x, a.y-b.y); }
function getNodeAt(x,y){ for(let i=nodes.length-1;i>=0;i--){ const n=nodes[i]; if(Math.hypot(n.x-x,n.y-y) <= 16) return n; } return null }
function getFrameAt(x, y) {
    for (let i = frames.length - 1; i >= 0; i--) {
        const frame = frames[i];
        if (x >= frame.x && x <= frame.x + frame.width &&
            y >= frame.y && y <= frame.y + frame.height) {
            return frame;
        }
    }
    return null;
}

// Undo/Redo functions
function saveState() {
    if (isUndoRedoAction) return;
    
    const state = {
        nodes: JSON.parse(JSON.stringify(nodes)),
        edges: JSON.parse(JSON.stringify(edges)),
        frames: JSON.parse(JSON.stringify(frames)),
        nodeIdCounter: nodeIdCounter,
        frameIdCounter: frameIdCounter
    };
    
    undoStack.push(state);
    redoStack = []; // Clear redo stack when new action is performed
    
    // Limit undo stack size
    if (undoStack.length > 50) {
        undoStack.shift();
    }
}

function undo() {
    if (undoStack.length === 0) return;
    
    isUndoRedoAction = true;
    
    // Save current state to redo stack
    const currentState = {
        nodes: JSON.parse(JSON.stringify(nodes)),
        edges: JSON.parse(JSON.stringify(edges)),
        frames: JSON.parse(JSON.stringify(frames)),
        nodeIdCounter: nodeIdCounter,
        frameIdCounter: frameIdCounter
    };
    redoStack.push(currentState);
    
    // Restore previous state
    const previousState = undoStack.pop();
    nodes = previousState.nodes;
    edges = previousState.edges;
    frames = previousState.frames;
    nodeIdCounter = previousState.nodeIdCounter;
    frameIdCounter = previousState.frameIdCounter;
    
    // Rebuild image cache for frames with background images
    imageCache.clear();
    frames.forEach(frame => {
        if (frame.backgroundImage) {
            const img = new Image();
            img.onload = function() {
                imageCache.set(frame.id, img);
            };
            img.src = frame.backgroundImage.src;
        }
    });
    
    // Clear selections and update UI
    selected.clear();
    selectedFrame = null;
    rightClickedEdge = null;
    highlightedPath.nodes = [];
    highlightedPath.edges = [];
    
    rebuildSelects();
    updateWeightControls();
    updateSelectedTagsList();
    updateTagRemoveSelect();
    updateFramesList();
    draw();
    
    isUndoRedoAction = false;
}

function redo() {
    if (redoStack.length === 0) return;
    
    isUndoRedoAction = true;
    
    // Save current state to undo stack
    const currentState = {
        nodes: JSON.parse(JSON.stringify(nodes)),
        edges: JSON.parse(JSON.stringify(edges)),
        frames: JSON.parse(JSON.stringify(frames)),
        nodeIdCounter: nodeIdCounter,
        frameIdCounter: frameIdCounter
    };
    undoStack.push(currentState);
    
    // Restore next state
    const nextState = redoStack.pop();
    nodes = nextState.nodes;
    edges = nextState.edges;
    frames = nextState.frames;
    nodeIdCounter = nextState.nodeIdCounter;
    frameIdCounter = nextState.frameIdCounter;
    
    // Rebuild image cache for frames with background images
    imageCache.clear();
    frames.forEach(frame => {
        if (frame.backgroundImage) {
            const img = new Image();
            img.onload = function() {
                imageCache.set(frame.id, img);
            };
            img.src = frame.backgroundImage.src;
        }
    });
    
    // Clear selections and update UI
    selected.clear();
    selectedFrame = null;
    rightClickedEdge = null;
    highlightedPath.nodes = [];
    highlightedPath.edges = [];
    
    rebuildSelects();
    updateWeightControls();
    updateSelectedTagsList();
    updateTagRemoveSelect();
    updateFramesList();
    draw();
    
    isUndoRedoAction = false;
}

// Grid snapping function
function snapToGrid(value) {
    return Math.round(value / GRID_SIZE) * GRID_SIZE;
}

// Search functions
function searchNodes(query) {
    if (!query.trim()) {
        searchResults = [];
        updateSearchResults();
        return;
    }
    
    const searchTerm = query.toLowerCase();
    searchResults = nodes.filter(node => 
        node.name.toLowerCase().includes(searchTerm) ||
        node.longName.toLowerCase().includes(searchTerm) ||
        (node.building && node.building.toLowerCase().includes(searchTerm)) ||
        (node.tags && node.tags.some(tag => String(tag).toLowerCase().includes(searchTerm)))
    );
    
    updateSearchResults();
}

function updateSearchResults() {
    const resultsContainer = document.getElementById('searchResults');
    resultsContainer.innerHTML = '';
    
    if (searchResults.length === 0) {
        resultsContainer.style.display = 'none';
        return;
    }
    
    resultsContainer.style.display = 'block';
    
    searchResults.forEach(node => {
        const resultItem = document.createElement('div');
        resultItem.className = 'search-result-item';
        
        const tagsText = node.tags && node.tags.length > 0 ? node.tags.join(', ') : 'No tags';
        resultItem.innerHTML = `
            <div class="node-name">${node.name}</div>
            <div class="node-details">${node.building || 'No building'} â€¢ ${tagsText}</div>
        `;
        
        resultItem.addEventListener('click', () => {
            selectNode(node.id);
            centerOnNode(node.id);
            document.getElementById('nodeSearch').value = '';
            resultsContainer.style.display = 'none';
        });
        
        resultsContainer.appendChild(resultItem);
    });
}

function centerOnNode(nodeId) {
    const node = nodes.find(n => n.id === nodeId);
    if (node) {
        // Center the view on the selected node
        const canvas = document.getElementById('graphCanvas');
        const centerX = canvas.width / 2;
        const centerY = canvas.height / 2;
        
        // Calculate the view position to center the node
        viewX = centerX - node.x * viewScale;
        viewY = centerY - node.y * viewScale;
        
        draw();
    }
}

function selectNode(nodeId) {
    selected.clear();
    selected.add(nodeId);
    updateSelectedList();
    draw();
}

function getEdgeAt(x,y){ 
  for(let i=edges.length-1;i>=0;i--){ 
    const e = edges[i];
    const a = nodes.find(n=>n.id===e.from);
    const b = nodes.find(n=>n.id===e.to);
    if(!a || !b) continue;
    
    // Check if point is near line segment
    const A = x - a.x;
    const B = y - a.y;
    const C = b.x - a.x;
    const D = b.y - a.y;
    
    const dot = A * C + B * D;
    const lenSq = C * C + D * D;
    let param = -1;
    
    if (lenSq !== 0) param = dot / lenSq;
    
    let xx, yy;
    if (param < 0) {
      xx = a.x;
      yy = a.y;
    } else if (param > 1) {
      xx = b.x;
      yy = b.y;
    } else {
      xx = a.x + param * C;
      yy = a.y + param * D;
    }
    
    const dx = x - xx;
    const dy = y - yy;
    const distance = Math.sqrt(dx * dx + dy * dy);
    
    if (distance <= 8) return e;
  }
  return null;
}

function addNode(x,y,name,longName){ 
  const n={
    id: nodeIdCounter++,
    x: x,
    y: y,
    name: name || ('Room '+(nodeIdCounter-1)), 
    longName: (longName && String(longName).trim()) || (name && String(name).trim()) || ('Room '+(nodeIdCounter-1)),
    building: null,
    tags: []
  }; 
  nodes.push(n); 
  rebuildSelects(); 
  draw(); 
  saveState();
  return n; 
}

function removeNode(node){ 
  nodes = nodes.filter(n=>n.id!==node.id); 
  edges = edges.filter(e=>e.from!==node.id && e.to!==node.id); 
  selected.delete(node.id); 
  rebuildSelects(); 
  draw(); 
  saveState();
}

function addEdge(aId,bId,w){ 
  if(aId===bId) return; // no self-edge
  // avoid duplicate undirected edges
  const exists = edges.find(e => (e.from===aId && e.to===bId) || (e.from===bId && e.to===aId));
  if(exists) return;
  const a = nodes.find(n=>n.id===aId), b = nodes.find(n=>n.id===bId);
  const weight = (w!==undefined && w!==null && w!=='') ? Number(w) : Math.round(dist(a,b));
  edges.push({from:aId,to:bId,weight}); 
  draw(); 
  saveState();
}

function removeEdgeBetween(aId,bId){ 
  edges = edges.filter(e=>!((e.from===aId&&e.to===bId)||(e.from===bId&&e.to===aId))); 
  draw(); 
  saveState();
}

function updateEdgeWeight(edge, newWeight) {
  if (edge && newWeight !== undefined && newWeight !== null && newWeight !== '') {
    edge.weight = Number(newWeight);
    draw();
    updateWeightControls();
    saveState();
  }
}

function rebuildSelects(){ 
  fromSelect.innerHTML=''; 
  toSelect.innerHTML='';
  for(const n of nodes){ 
    const opt=document.createElement('option'); 
    opt.value=n.id; 
    opt.textContent=n.name||('Room '+n.id); 
    fromSelect.appendChild(opt.cloneNode(true)); 
    toSelect.appendChild(opt.cloneNode(true)); 
  }
  updateSelectedList(); 
  updateSelectedTagsList();
  updateTagRemoveSelect();
}

function updateSelectedList(){ 
  if(selected.size===0){ 
    selectedList.innerHTML='(none)'; 
    return; 
  }
  selectedList.innerHTML = Array.from(selected).map(id=>{ 
    const n=nodes.find(x=>x.id===id); 
    const label = n.longName || n.name; 
    const buildingInfo = n.building ? ` â€¢ ${n.building}` : '';
    const tagsInfo = n.tags && n.tags.length > 0 ? ` â€¢ [${n.tags.join(', ')}]` : '';
    return `<div>${label} <small style="color:var(--muted)">(id:${n.id})${buildingInfo}${tagsInfo}</small></div>` 
  }).join(''); 
  
  // Update tag editor when selection changes
  updateSelectedTagsList();
  updateTagRemoveSelect();
}

function updateWeightControls() {
  if (rightClickedEdge) {
    const fromNode = nodes.find(n => n.id === rightClickedEdge.from);
    const toNode = nodes.find(n => n.id === rightClickedEdge.to);
    weightControls.innerHTML = `
      <div class="weight-row">
        <label>${fromNode?.name || rightClickedEdge.from} â†’ ${toNode?.name || rightClickedEdge.to}</label>
      </div>
      <div class="weight-row">
        <input type="number" id="weightInput" value="${rightClickedEdge.weight}" placeholder="Weight" />
        <button id="updateWeightBtn">Update</button>
        <button id="resetWeightBtn">Reset</button>
      </div>
    `;
    
    // Add event listeners
    document.getElementById('updateWeightBtn')?.addEventListener('click', () => {
      const newWeight = document.getElementById('weightInput').value;
      updateEdgeWeight(rightClickedEdge, newWeight);
    });
    
    document.getElementById('resetWeightBtn')?.addEventListener('click', () => {
      const fromNode = nodes.find(n => n.id === rightClickedEdge.from);
      const toNode = nodes.find(n => n.id === rightClickedEdge.to);
      if (fromNode && toNode) {
        rightClickedEdge.weight = Math.round(dist(fromNode, toNode));
        draw();
        updateWeightControls();
      }
    });
  } else {
    weightControls.innerHTML = '<div class="hint">Right-click on an edge to edit its weight</div>';
  }
}

// Frame functions
function createFrame() {
  const name = frameNameInput.value.trim();
  const color = frameColorInput.value;
  
  if (!name) {
    alert('Please enter a frame name');
    return;
  }
  
  const frame = {
    id: frameIdCounter++,
    name: name,
    color: color,
    nodes: [],
    x: 100,
    y: 100,
    width: 300,
    height: 200,
    backgroundImage: null // Add background image support
  };
  
  frames.push(frame);
  frameNameInput.value = '';
  updateFramesList();
  draw();
  saveState();
}

function deleteFrame() {
  if (selectedFrame) {
    frames = frames.filter(f => f.id !== selectedFrame.id);
    selectedFrame = null;
    updateFramesList();
    draw();
    saveState();
  } else {
    alert('Please select a frame to delete');
  }
}

function updateFramesList() {
  if (frames.length === 0) {
    framesList.innerHTML = '<div class="hint">No frames created yet</div>';
    return;
  }
  
  framesList.innerHTML = frames.map(frame => `
    <div class="frame-item" data-frame-id="${frame.id}" style="background: ${frame.color}20; border: 1px solid ${frame.color}40;">
      <div style="font-weight: bold; color: ${frame.color}">${frame.name}</div>
      <div style="font-size: 11px; color: var(--muted)">
        ${frame.nodes.length} nodes
        ${frame.backgroundImage ? ' â€¢ ðŸ“· Background' : ''}
      </div>
    </div>
  `).join('');
  
  // Add click handlers
  framesList.querySelectorAll('.frame-item').forEach(item => {
    item.addEventListener('click', () => {
      const frameId = Number(item.dataset.frameId);
      selectedFrame = frames.find(f => f.id === frameId);
      draw();
    });
  });
}

function addNodeToFrame(nodeId, frameId) {
  const frame = frames.find(f => f.id === frameId);
  const node = nodes.find(n => n.id === nodeId);
  
  if (frame && node && !frame.nodes.includes(nodeId)) {
    frame.nodes.push(nodeId);
    updateFramesList();
    draw();
    saveState();
  }
}

function removeNodeFromFrame(nodeId, frameId) {
  const frame = frames.find(f => f.id === frameId);
  if (frame) {
    frame.nodes = frame.nodes.filter(id => id !== nodeId);
    updateFramesList();
    draw();
    saveState();
  }
}

function handleBackgroundImageUpload(e) {
  const file = e.target.files[0];
  if (!file) return;
  
  if (!selectedFrame) {
    alert('Please select a frame first');
    return;
  }
  
  const reader = new FileReader();
  reader.onload = function(event) {
    const img = new Image();
    img.onload = function() {
      selectedFrame.backgroundImage = {
        src: event.target.result,
        width: img.width,
        height: img.height
      };
      
      // Cache the image for better performance
      imageCache.set(selectedFrame.id, img);
      
      draw();
      saveState();
      e.target.value = ''; // Clear the input
    };
    img.src = event.target.result;
  };
  reader.readAsDataURL(file);
}

function clearBackgroundImage() {
  if (!selectedFrame) {
    alert('Please select a frame first');
    return;
  }
  
  selectedFrame.backgroundImage = null;
  imageCache.delete(selectedFrame.id);
  draw();
  saveState();
}

// Tag editor functions
function addTagToSelected() {
  const tag = tagInput.value.trim();
  if (!tag) {
    alert('Please enter a tag name');
    return;
  }
  
  if (selected.size === 0) {
    alert('Please select at least one node');
    return;
  }
  
  selected.forEach(nodeId => {
    const node = nodes.find(n => n.id === nodeId);
    if (node) {
      if (!node.tags) node.tags = [];
      if (!node.tags.includes(tag)) {
        node.tags.push(tag);
      }
    }
  });
  
  tagInput.value = '';
  updateSelectedTagsList();
  updateTagRemoveSelect();
  draw();
  saveState();
}

function removeTagFromSelected() {
  const tag = tagRemoveSelect.value;
  if (!tag) {
    alert('Please select a tag to remove');
    return;
  }
  
  if (selected.size === 0) {
    alert('Please select at least one node');
    return;
  }
  
  selected.forEach(nodeId => {
    const node = nodes.find(n => n.id === nodeId);
    if (node && node.tags) {
      node.tags = node.tags.filter(t => t !== tag);
    }
  });
  
  updateSelectedTagsList();
  updateTagRemoveSelect();
  draw();
  saveState();
}

function updateSelectedTagsList() {
  if (selected.size === 0) {
    selectedTagsList.innerHTML = '(none selected)';
    return;
  }
  
  const allTags = new Set();
  selected.forEach(nodeId => {
    const node = nodes.find(n => n.id === nodeId);
    if (node && node.tags) {
      node.tags.forEach(tag => allTags.add(tag));
    }
  });
  
  if (allTags.size === 0) {
    selectedTagsList.innerHTML = '(no tags)';
  } else {
    selectedTagsList.innerHTML = Array.from(allTags).map(tag => 
      `<div class="tag-badge">${tag}</div>`
    ).join('');
  }
}

function updateTagRemoveSelect() {
  tagRemoveSelect.innerHTML = '<option value="">Select tag to remove</option>';
  
  if (selected.size === 0) return;
  
  const allTags = new Set();
  selected.forEach(nodeId => {
    const node = nodes.find(n => n.id === nodeId);
    if (node && node.tags) {
      node.tags.forEach(tag => allTags.add(tag));
    }
  });
  
  Array.from(allTags).forEach(tag => {
    const option = document.createElement('option');
    option.value = tag;
    option.textContent = tag;
    tagRemoveSelect.appendChild(option);
  });
}

// Drawing
function draw(){ 
  ctx.clearRect(0,0,canvas.width/DPR,canvas.height/DPR);
  
  // Apply view transformation
  ctx.save();
  ctx.translate(viewX, viewY);
  ctx.scale(viewScale, viewScale);
  
  // Draw grid when Ctrl is pressed
  if (isCtrlPressed) {
    ctx.strokeStyle = 'rgba(255,255,255,0.1)';
    ctx.lineWidth = 1;
    
    const width = canvas.width / DPR;
    const height = canvas.height / DPR;
    
    // Vertical lines
    for (let x = 0; x <= width; x += GRID_SIZE) {
      ctx.beginPath();
      ctx.moveTo(x, 0);
      ctx.lineTo(x, height);
      ctx.stroke();
    }
    
    // Horizontal lines
    for (let y = 0; y <= height; y += GRID_SIZE) {
      ctx.beginPath();
      ctx.moveTo(0, y);
      ctx.lineTo(width, y);
      ctx.stroke();
    }
  }
  
  // Draw frames first (background)
  for (const frame of frames) {
    // Draw background image if present
    if (frame.backgroundImage) {
      const img = imageCache.get(frame.id);
      if (img) {
        // Calculate aspect ratio to fit image within frame
        const frameAspect = frame.width / frame.height;
        const imgAspect = frame.backgroundImage.width / frame.backgroundImage.height;
        
        let drawWidth, drawHeight, drawX, drawY;
        
        if (imgAspect > frameAspect) {
          // Image is wider than frame, fit to width
          drawWidth = frame.width;
          drawHeight = frame.width / imgAspect;
          drawX = frame.x;
          drawY = frame.y + (frame.height - drawHeight) / 2;
        } else {
          // Image is taller than frame, fit to height
          drawHeight = frame.height;
          drawWidth = frame.height * imgAspect;
          drawX = frame.x + (frame.width - drawWidth) / 2;
          drawY = frame.y;
        }
        
        ctx.drawImage(img, drawX, drawY, drawWidth, drawHeight);
      } else {
        // Fallback to original image loading if not in cache
        const img = new Image();
        img.onload = function() {
          // Calculate aspect ratio to fit image within frame
          const frameAspect = frame.width / frame.height;
          const imgAspect = img.width / img.height;
          
          let drawWidth, drawHeight, drawX, drawY;
          
          if (imgAspect > frameAspect) {
            // Image is wider than frame, fit to width
            drawWidth = frame.width;
            drawHeight = frame.width / imgAspect;
            drawX = frame.x;
            drawY = frame.y + (frame.height - drawHeight) / 2;
          } else {
            // Image is taller than frame, fit to height
            drawHeight = frame.height;
            drawWidth = frame.height * imgAspect;
            drawX = frame.x + (frame.width - drawWidth) / 2;
            drawY = frame.y;
          }
          
          ctx.drawImage(img, drawX, drawY, drawWidth, drawHeight);
        };
        img.src = frame.backgroundImage.src;
      }
    }
    
    // Draw frame background
    ctx.fillStyle = frame.color + '10';
    ctx.strokeStyle = frame.color + '60';
    ctx.lineWidth = 2;
    ctx.setLineDash([5, 5]);
    
    ctx.beginPath();
    ctx.rect(frame.x, frame.y, frame.width, frame.height);
    ctx.fill();
    ctx.stroke();
    
    // Frame label
    ctx.fillStyle = frame.color;
    ctx.font = '12px sans-serif';
    ctx.textAlign = 'left';
    ctx.textBaseline = 'top';
    ctx.fillText(frame.name, frame.x + 8, frame.y + 8);
    
    // Highlight selected frame
    if (selectedFrame && selectedFrame.id === frame.id) {
      ctx.strokeStyle = frame.color;
      ctx.lineWidth = 3;
      ctx.setLineDash([]);
      ctx.stroke();
    }
  }
  
  // Reset line dash
  ctx.setLineDash([]);
  
  // edges
  for(const e of edges){ 
    const a = nodes.find(n=>n.id===e.from); 
    const b = nodes.find(n=>n.id===e.to);
    if (!a || !b) continue;
    
    const isHighlighted = highlightedPath.edges.some(p=> (p.from===e.from && p.to===e.to) || (p.from===e.to && p.to===e.from));
    const isRightClicked = rightClickedEdge && ((e.from === rightClickedEdge.from && e.to === rightClickedEdge.to) || (e.from === rightClickedEdge.to && e.to === rightClickedEdge.from));
    
    ctx.lineWidth = isHighlighted ? 4 : (isRightClicked ? 3 : 2);
    ctx.strokeStyle = isHighlighted ? '#ffffff' : (isRightClicked ? '#ffffff' : 'rgba(255,255,255,0.3)');
    ctx.beginPath(); 
    ctx.moveTo(a.x,a.y); 
    ctx.lineTo(b.x,b.y); 
    ctx.stroke();
    
    // weight label
    const mx=(a.x+b.x)/2, my=(a.y+b.y)/2;
    ctx.fillStyle = 'rgba(255,255,255,0.8)'; 
    ctx.font='12px sans-serif'; 
    ctx.fillText(e.weight, mx+6, my-6);
  }
  
  // nodes
  for(const n of nodes){ 
    const isSel = selected.has(n.id); 
    const isHover = hovered && hovered.id===n.id;
    
    // Label to display
    const label = isSel ? (n.longName || n.name) : n.name;
    
    ctx.font = '12px sans-serif';
    const textWidth = ctx.measureText(label).width;
    const paddingX = 10; // space left & right of text
    const radius = 16; // node radius for normal nodes
    
    ctx.beginPath();
    
    if (isSel) {
      // Draw pill shape (rounded rectangle) based on text width
      const totalWidth = textWidth + paddingX * 2;
      const height = radius * 2;
      const x = n.x - totalWidth / 2;
      const y = n.y - height / 2;
      
      // Rounded rectangle
      ctx.moveTo(x + radius, y);
      ctx.lineTo(x + totalWidth - radius, y);
      ctx.arcTo(x + totalWidth, y, x + totalWidth, y + radius, radius);
      ctx.lineTo(x + totalWidth, y + height - radius);
      ctx.arcTo(x + totalWidth, y + height, x + totalWidth - radius, y + height, radius);
      ctx.lineTo(x + radius, y + height);
      ctx.arcTo(x, y + height, x, y + height - radius, radius);
      ctx.lineTo(x, y + radius);
      ctx.arcTo(x, y, x + radius, y, radius);
      
      ctx.fillStyle = '#ffffff';
      ctx.fill();
      ctx.strokeStyle = '#000000';
      ctx.lineWidth = 3;
      ctx.stroke();
    } else {
      // Regular circle for non-selected nodes
      ctx.arc(n.x, n.y, radius, 0, Math.PI * 2);
      ctx.fillStyle = isHover ? 'rgba(255,255,255,0.6)' : 'rgba(255,255,255,0.2)';
      ctx.fill();
    }
    
    // Draw label
    ctx.fillStyle = isSel ? '#000000' : '#ffffff';
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';
    ctx.fillText(label, n.x, n.y);
  }
  ctx.restore(); // Restore context after drawing
}

// Interaction
canvas.addEventListener('mousedown', e=>{
  const rect = canvas.getBoundingClientRect();
  const x = (e.clientX - rect.left);
  const y = (e.clientY - rect.top);
  
  // Transform coordinates for view transformation
  const transformedX = (x - viewX) / viewScale;
  const transformedY = (y - viewY) / viewScale;
  
  // Middle mouse button for panning
  if (e.button === 1) { // Middle mouse button
    e.preventDefault();
    isPanning = true;
    lastMousePos = {x, y};
    canvas.style.cursor = 'grabbing';
    return;
  }
  
  // Check if clicking on a node first (nodes have priority over frames)
  const node = getNodeAt(transformedX, transformedY);
  if(node){
    dragging = { type: 'node', node: node };
    dragOffset.x = transformedX - node.x;
    dragOffset.y = transformedY - node.y;
    return;
  }
  
  // If no node was clicked, check for frames
  const clickedFrame = getFrameAt(transformedX, transformedY);
  if (clickedFrame) {
    if (e.shiftKey) {
      // Shift+click to add/remove nodes from frame
      const node = getNodeAt(transformedX, transformedY);
      if (node) {
        if (clickedFrame.nodes.includes(node.id)) {
          removeNodeFromFrame(node.id, clickedFrame.id);
        } else {
          addNodeToFrame(node.id, clickedFrame.id);
        }
      }
    } else {
      // Regular click to select frame and start dragging
      selectedFrame = clickedFrame;
      dragging = { type: 'frame', frame: clickedFrame };
      dragOffset.x = transformedX - clickedFrame.x;
      dragOffset.y = transformedY - clickedFrame.y;
      draw();
      return;
    }
  }
});

canvas.addEventListener('mouseup', e=>{
  if (isPanning) {
    isPanning = false;
    canvas.style.cursor = 'default';
    return;
  }
  
  if (dragging && dragging.type === 'frame') {
    selectedFrame = dragging.frame;
  }
  if (dragging) {
    saveState();
  }
  dragging = null;
});

canvas.addEventListener('mousemove', e=>{
  const rect = canvas.getBoundingClientRect();
  const x = (e.clientX - rect.left);
  const y = (e.clientY - rect.top);

  // Handle panning
  if (isPanning) {
    const deltaX = x - lastMousePos.x;
    const deltaY = y - lastMousePos.y;
    viewX += deltaX;
    viewY += deltaY;
    lastMousePos = {x, y};
    draw();
    return;
  }

  // Transform coordinates for view transformation
  const transformedX = (x - viewX) / viewScale;
  const transformedY = (y - viewY) / viewScale;

  if(dragging){
    if (dragging.type === 'frame') {
      let newX = transformedX - dragOffset.x;
      let newY = transformedY - dragOffset.y;
      
      // Apply grid snapping if Ctrl is pressed
      if (isCtrlPressed) {
        newX = snapToGrid(newX);
        newY = snapToGrid(newY);
      }
      
      dragging.frame.x = newX;
      dragging.frame.y = newY;
    } else if (dragging.type === 'node') {
      let newX = transformedX - dragOffset.x;
      let newY = transformedY - dragOffset.y;
      
      // Apply grid snapping if Ctrl is pressed
      if (isCtrlPressed) {
        newX = snapToGrid(newX);
        newY = snapToGrid(newY);
      }
      
      dragging.node.x = newX;
      dragging.node.y = newY;
    }
    draw();
    return;
  }

  // hover detection
  const node = getNodeAt(transformedX, transformedY);
  if(node !== hovered){
    hovered = node;
    draw();
  }
});

canvas.addEventListener('click', e=>{
  const rect = canvas.getBoundingClientRect();
  const x = (e.clientX - rect.left);
  const y = (e.clientY - rect.top);
  
  // Transform coordinates for view transformation
  const transformedX = (x - viewX) / viewScale;
  const transformedY = (y - viewY) / viewScale;
  
  const node = getNodeAt(transformedX, transformedY);
  const edge = getEdgeAt(transformedX, transformedY);

  if(node){
    if(e.shiftKey){
      if(selected.has(node.id)) selected.delete(node.id);
      else selected.add(node.id);
      updateSelectedList();
      draw();
    } else {
      selected.clear();
      selected.add(node.id);
      updateSelectedList();
      draw();
    }
  } else if (edge) {
    // Left-click on edge for weight editing
    rightClickedEdge = edge;
    updateWeightControls();
    draw();
  } else {
    // Left-click on empty space - clear edge selection
    rightClickedEdge = null;
    updateWeightControls();
    draw();
  }
});

canvas.addEventListener('contextmenu', e => {
  e.preventDefault();
  const rect = canvas.getBoundingClientRect();
  const x = (e.clientX - rect.left);
  const y = (e.clientY - rect.top);
  
  // Transform coordinates for view transformation
  const transformedX = (x - viewX) / viewScale;
  const transformedY = (y - viewY) / viewScale;
  
  const node = getNodeAt(transformedX, transformedY);

  if(!node){
    // Right-clicked empty space â†’ add new node
    const name = prompt('Enter room name:');
    if (name !== null && name.trim()) {
      const finalName = name.trim();
      addNode(transformedX, transformedY, finalName, finalName);
    }
  }
});

// Zoom functionality
canvas.addEventListener('wheel', e => {
  e.preventDefault();
  
  const rect = canvas.getBoundingClientRect();
  const mouseX = e.clientX - rect.left;
  const mouseY = e.clientY - rect.top;
  
  // Calculate zoom factor
  const zoomFactor = e.deltaY > 0 ? 0.9 : 1.1;
  const newScale = Math.max(0.1, Math.min(5, viewScale * zoomFactor));
  
  // Calculate the point under the mouse before zoom
  const pointXBeforeZoom = (mouseX - viewX) / viewScale;
  const pointYBeforeZoom = (mouseY - viewY) / viewScale;
  
  // Update scale
  viewScale = newScale;
  
  // Calculate the point under the mouse after zoom
  const pointXAfterZoom = (mouseX - viewX) / viewScale;
  const pointYAfterZoom = (mouseY - viewY) / viewScale;
  
  // Adjust view position to keep the point under the mouse
  viewX += (pointXAfterZoom - pointXBeforeZoom) * viewScale;
  viewY += (pointYAfterZoom - pointYBeforeZoom) * viewScale;
  
  draw();
});

// Keyboard shortcuts
document.addEventListener('keydown', e => {
  if (e.ctrlKey) {
    isCtrlPressed = true;
    document.getElementById('gridIndicator').style.display = 'block';
    draw(); // Redraw to show grid
  }
  if (e.key === 'z') {
    e.preventDefault();
    undo();
  } else if (e.key === 'y') {
    e.preventDefault();
    redo();
  } else if (e.key === 'F2') {
    e.preventDefault();
    if (selected.size === 1) {
      const nodeId = Array.from(selected)[0];
      const node = nodes.find(n => n.id === nodeId);
      if (node) {
        const newName = prompt('Enter new name for node:', node.name);
        if (newName && newName.trim() && newName.trim() !== node.name) {
          const newLongName = prompt('Enter new long name (or leave empty to use short name):', node.longName);
          const finalLongName = newLongName && newLongName.trim() ? newLongName.trim() : newName.trim();
          
          node.name = newName.trim();
          node.longName = finalLongName;
          
          rebuildSelects();
          updateSelectedList();
          draw();
          saveState();
        }
      }
    }
  } else if (e.key === 'Delete') {
    e.preventDefault();
    // Delete selected nodes
    if (selected.size > 0) {
        const selectedArray = Array.from(selected);
        selectedArray.forEach(nodeId => {
            const node = nodes.find(n => n.id === nodeId);
            if (node) {
                removeNode(node);
            }
        });
        selected.clear();
        updateSelectedList();
    }
    
    // Delete selected frame
    if (selectedFrame) {
        deleteFrame();
        selectedFrame = null;
    }
    
    // Delete selected edge (if any edge is selected for weight editing)
    if (rightClickedEdge) {
        removeEdgeBetween(rightClickedEdge.from, rightClickedEdge.to);
        rightClickedEdge = null;
        updateWeightControls();
    }
    
    draw();
  }
});

document.addEventListener('keyup', e => {
  if (!e.ctrlKey) {
    isCtrlPressed = false;
    document.getElementById('gridIndicator').style.display = 'none';
    draw(); // Redraw to hide grid
  }
});

// Buttons
connectSelectedBtn.addEventListener('click', () => {
  if(selected.size !== 2) {
    alert('Select exactly two nodes with Shift+Click');
    return;
  }
  const [a,b] = Array.from(selected);
  addEdge(a,b);
  saveState();
});

removeSelectedBtn.addEventListener('click', () => {
  Array.from(selected).forEach(id => {
    const node = nodes.find(n=>n.id===id);
    if(node) removeNode(node);
  });
  selected.clear();
  updateSelectedList();
  draw();
  saveState();
});

connectBtn.addEventListener('click', () => {
  const fromId = Number(fromSelect.value);
  const toId = Number(toSelect.value);
  const w = edgeWeightInput.value;
  addEdge(fromId,toId,w);
  saveState();
});

removeEdgeBtn.addEventListener('click', () => {
  const fromId = Number(fromSelect.value);
  const toId = Number(toSelect.value);
  removeEdgeBetween(fromId,toId);
  saveState();
});

exportBtn.addEventListener('click', () => {
  const data = {nodes, edges, frames};
  jsonBox.value = JSON.stringify(data, null, 2);
});

importBtn.addEventListener('click', () => {
  try {
    const data = JSON.parse(jsonBox.value);
    if(Array.isArray(data.nodes) && Array.isArray(data.edges)){
      nodes = data.nodes.map(n => ({...n}));
      edges = data.edges.map(e => ({...e}));
      frames = data.frames ? data.frames.map(f => ({...f})) : [];
      nodeIdCounter = nodes.reduce((max, n) => Math.max(max, n.id), 0) + 1;
      frameIdCounter = frames.reduce((max, f) => Math.max(max, f.id), 0) + 1;
      
      // Rebuild image cache for frames with background images
      imageCache.clear();
      frames.forEach(frame => {
        if (frame.backgroundImage) {
          const img = new Image();
          img.onload = function() {
            imageCache.set(frame.id, img);
            draw(); // Redraw when image loads
          };
          img.src = frame.backgroundImage.src;
        }
      });
      
      selected.clear();
      selectedFrame = null;
      highlightedPath.nodes = [];
      highlightedPath.edges = [];
      rightClickedEdge = null;
      rebuildSelects();
      updateWeightControls();
      updateFramesList();
      updateSelectedTagsList();
      updateTagRemoveSelect();
      draw();
      infoBox.textContent = 'Data imported successfully.';
      saveState();
    } else {
      alert('Invalid JSON format');
    }
  } catch(e){
    alert('Invalid JSON');
  }
});

exportForNavBtn.addEventListener('click', () => {
  const data = {nodes, edges, frames};
  const blob = new Blob([JSON.stringify(data, null, 2)], {type: 'application/json'});
  const url = URL.createObjectURL(blob);
  const a = document.createElement('a');
  a.href = url;
  a.download = 'navigation-graph.json';
  a.click();
  URL.revokeObjectURL(url);
  infoBox.textContent = 'Graph exported for navigator.';
});

// Load rooms.json â†’ import as nodes without connections
async function loadRoomsJson(){
  roomsFileInput.click();
}

function importRoomsFromArray(arr){
  if(!Array.isArray(arr) || arr.length===0){
    infoBox.textContent = 'rooms.json: no rooms found.';
    return;
  }
  // Reset graph state
  nodes = [];
  edges = [];
  selected.clear();
  highlightedPath.nodes = [];
  highlightedPath.edges = [];
  rightClickedEdge = null;
  nodeIdCounter = 1;

  // Layout positions if x/y missing
  const rect = canvas.getBoundingClientRect();
  const width = rect.width || 800;
  const height = rect.height || 600;
  const count = arr.length;
  const cols = Math.ceil(Math.sqrt(count));
  const rows = Math.ceil(count / cols);
  const padding = 48;
  const cellW = Math.max(1, (width - padding*2) / cols);
  const cellH = Math.max(1, (height - padding*2) / rows);

  let i = 0;
  for(const item of arr){
    const name = (item && item.name) ? String(item.name) : ('Room ' + (i+1));
    const longName = (item && (item.longName || item.longname || item.fullName || item.title)) ? String(item.longName || item.longname || item.fullName || item.title) : name;
    let x = Number(item && item.x);
    let y = Number(item && item.y);
    if(!Number.isFinite(x) || !Number.isFinite(y)){
      const c = i % cols;
      const r = Math.floor(i / cols);
      x = Math.round(padding + c*cellW + cellW/2);
      y = Math.round(padding + r*cellH + cellH/2);
    }
    const node = addNode(x, y, name, longName);
    
    // Import building data if available
    if (item && item.building) {
      node.building = String(item.building);
    }
    
    // Import tags data if available
    if (item && item.tags) {
      node.tags = Array.isArray(item.tags) ? [...item.tags] : [String(item.tags)];
    }
    
    i++;
  }
  infoBox.textContent = `Loaded ${count} rooms from rooms.json.`;
  rebuildSelects();
  updateWeightControls();
  updateSelectedTagsList();
  updateTagRemoveSelect();
  draw();
  saveState();
}

loadRoomsBtn.addEventListener('click', () => {
  loadRoomsJson();
});

resetBtn.addEventListener('click', () => {
  if(confirm('Reset all nodes, edges, and frames?')){
    nodes = [];
    edges = [];
    frames = [];
    selected.clear();
    highlightedPath.nodes = [];
    highlightedPath.edges = [];
    rightClickedEdge = null;
    nodeIdCounter = 1;
    rebuildSelects();
    updateWeightControls();
    updateSelectedTagsList();
    updateTagRemoveSelect();
    draw();
    infoBox.textContent = 'Reset done.';
    saveState();
  }
});

clearHighlightBtn.addEventListener('click', () => {
  highlightedPath.nodes = [];
  highlightedPath.edges = [];
  infoBox.textContent = 'Highlight cleared.';
  draw();
});

zoomFitBtn.addEventListener('click', () => {
  if (nodes.length === 0) {
    alert('No nodes to fit to view.');
    return;
  }
  
  const minX = Math.min(...nodes.map(n => n.x));
  const maxX = Math.max(...nodes.map(n => n.x));
  const minY = Math.min(...nodes.map(n => n.y));
  const maxY = Math.max(...nodes.map(n => n.y));
  
  const padding = 100;
  const scaleX = (canvas.width/DPR - padding*2) / (maxX - minX);
  const scaleY = (canvas.height/DPR - padding*2) / (maxY - minY);
  const scale = Math.min(scaleX, scaleY, 1);
  
  // Center the view
  const centerX = (minX + maxX) / 2;
  const centerY = (minY + maxY) / 2;
  
  // Update view transformation variables
  viewScale = scale;
  viewX = (canvas.width/DPR/2) - (centerX * scale);
  viewY = (canvas.height/DPR/2) - (centerY * scale);
  
  draw();
  infoBox.textContent = 'View fitted to nodes.';
});

// Dijkstra shortest path
function findShortestPath(startName, endName){
  const startNode = nodes.find(n=>n.name.toLowerCase() === startName.toLowerCase());
  const endNode = nodes.find(n=>n.name.toLowerCase() === endName.toLowerCase());
  if(!startNode || !endNode){
    infoBox.textContent = 'Start or end room not found.';
    return;
  }
  // Dijkstra's algorithm
  const distMap = new Map();
  const prevMap = new Map();
  const Q = new Set(nodes.map(n=>n.id));
  nodes.forEach(n=>distMap.set(n.id, Infinity));
  distMap.set(startNode.id, 0);

  while(Q.size){
    // node in Q with smallest dist
    let u = null, uDist = Infinity;
    for(const id of Q){
      const d = distMap.get(id);
      if(d < uDist){ u = id; uDist = d; }
    }
    if(u === null) break;
    Q.delete(u);
    if(u === endNode.id) break;

    const neighbors = edges.filter(e => e.from === u || e.to === u);
    for(const e of neighbors){
      const v = (e.from === u) ? e.to : e.from;
      if(!Q.has(v)) continue;
      const alt = distMap.get(u) + e.weight;
      if(alt < distMap.get(v)){
        distMap.set(v, alt);
        prevMap.set(v, u);
      }
    }
  }

  // reconstruct path
  const pathNodes = [];
  const pathEdges = [];
  let current = endNode.id;
  while(current !== undefined && current !== startNode.id){
    pathNodes.unshift(current);
    const prev = prevMap.get(current);
    if(prev !== undefined){
      pathEdges.unshift({from: prev, to: current});
    }
    current = prev;
  }
  if(current === startNode.id) pathNodes.unshift(startNode.id);
  else {
    infoBox.textContent = 'No path found.';
    highlightedPath.nodes = [];
    highlightedPath.edges = [];
    draw();
    return;
  }

  highlightedPath.nodes = pathNodes;
  highlightedPath.edges = pathEdges;
  infoBox.textContent = `Shortest path found (${distMap.get(endNode.id)} units)`;
  draw();
}

findPathBtn.addEventListener('click', () => {
  findShortestPath(startNameInput.value.trim(), endNameInput.value.trim());
});

roomsFileInput.addEventListener('change', (e) => {
  const file = e.target.files && e.target.files[0];
  if(!file) return;
  const reader = new FileReader();
  reader.onload = () => {
    try{
      const data = JSON.parse(String(reader.result));
      const roomsArray = Array.isArray(data) ? data : (Array.isArray(data.rooms) ? data.rooms : null);
      if(!roomsArray){
        infoBox.textContent = 'rooms.json format unsupported. Use an array or {"rooms": [...] }';
        return;
      }
      const normalized = roomsArray.map((r,i)=>{
        if(typeof r === 'string') return { name: r };
        if(r && typeof r === 'object') return r;
        return { name: 'Room ' + (i+1) };
      });
      importRoomsFromArray(normalized);
      roomsFileInput.value = '';
    } catch(err){
      console.error(err);
      alert('Invalid JSON in selected file.');
    }
  };
  reader.onerror = () => {
    alert('Failed to read file.');
  };
  reader.readAsText(file);
});

// Search input event listener
document.getElementById('nodeSearch').addEventListener('input', (e) => {
    clearTimeout(searchTimeout);
    searchTimeout = setTimeout(() => {
        searchNodes(e.target.value);
    }, 300);
});

// Close search results when clicking outside
document.addEventListener('click', (e) => {
    const searchContainer = document.querySelector('.search-container');
    if (!searchContainer.contains(e.target)) {
        document.getElementById('searchResults').style.display = 'none';
    }
});

// Initialize
updateWeightControls();
updateSelectedTagsList();
updateTagRemoveSelect();
saveState(); // Save initial state
</script>
</body>
</html> 